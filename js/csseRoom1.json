{
    "csse": [
        {
            "time": "1:15 PM - 1:30 PM",
            "projectId": "csse-1-115",
            "title": "Teaching Tools: A Canvas LTI Application",
            "studentName": "Brian Kieffer",
            "studentMajor": "CSSE",
            "projectType": "UWB CSS Faculty Research",
            "facultyAdvisor": "Mr. Mark Kochanski",
            "posterLink": "./posters/csse/Brian Joseph Kieffer.png",
            "abstract": "Both students and professors use Canvas as an online learning tool for school. It is great for students to stay in the loop of assignments and important documents. However, it lacks functionality for professors. The site and processes are redundant for professors and it is obnoxious to use when needing to export files to Google Drive. An example of redundancy is when a new quarter starts and a professor is teaching the same course. Canvas creates a blank canvas for the new quarter, so the professor has to look at the previous quarter’s section and copy the settings over to the new section. A lot of time is wasted on these repetitive tasks. \n\nI began working on Teaching Tools, a Canvas LTI application that will help professors save time. The web application will be displayed as a side tab in a canvas course, similarly to zoom. During this quarter I gained knowledge regarding the Canvas API, Google Drive API and gained more experience with React. Many weeks consisted of refactoring my work and creating a website that was appealing to the eye, but also efficient and clear. My partner and I created a website that consisted of a React front end, a Flask middle layer, and a Python back end. By the end of the quarter, we were able to produce a website that truly saves the professor’s time with importing and exporting files, and the ability to download the settings of a previous course. Each function may require a professor to enter some information, but once they click the submit button, the application will do the work for them. The website consists of functions such as: importing class settings and student groups, exporting student roster, class settings, student groups, an assignment or quiz submissions, exporting files from Canvas to Google Drive, and importing files from Google Drive as Canvas Files or Pages."
        },
        {
            "time": "1:30 PM - 1:45 PM",
            "projectId": "csse-1-130",
            "title": "UWB Teaching Tools",
            "studentName": "Sean Merz",
            "studentMajor": "CSSE",
            "projectType": "UWB CSS Faculty Research",
            "facultyAdvisor": "Mr. Mark Kochanski",
            "posterLink": "./posters/csse/Sean Merz.jpg",
            "abstract": "I helped build the foundation of Teaching Tools, a web service for instructors (potentially students in the future) designed to enhance the functionality of Canvas. Another student and I started with an Azure DevOps board full of Epics, Features, and User Stories, and created a front-end website that through API calls interacts with Canvas to help make instructors lives easier. We created the front-end with React and MUI and used Python with Flask as the back-end server. The site will be hosted by Microsoft’s Azure soon. \n\nWe chose to work with MUI, a React user interface library, because it is well documented, easy to use, and its library is large. I didn’t have much experience working with front-end programming, so going with MUI made sense. Working with Python and Flask was Professor Kochanski’s idea and it worked very well. It is also very easy to use and made the project very enjoyable. We wanted to make sure that our code was easy to understand and simple for the people who would be adding on to the project in the future. \n\nThe result of the project is a service that includes twelve features ranging from importing/exporting a course roster, groups, settings, and navigation, to connecting and exchange data with Google through its API. The project was significant because it has the potential to be used by all instructors at UWB, and possibly other institutions that use Canvas. I’d imagine Professor Kochanski will start getting requests for added features in the not-too-distant future."
        },
        {
            "time": "1:45 PM - 2:00 PM",
            "projectId": "csse-1-145",
            "title": "Designing A Hands-on Introduction To Modern Industry Engineering Practices",
            "studentName": "Shaun Stangler",
            "studentMajor": "CSSE",
            "projectType": "UWB CSS Faculty Research",
            "facultyAdvisor": "Mr. Mark Kochanski",
            "posterLink": "./posters/csse/Shaun Stangler.png",
            "abstract": "Modern software engineering team culture, practices, processes, and expectations can often induce culture shock with interns or recent graduates used to classical learning environments. By incrementally introducing industry technical, process, and collaboration practices while using real-world toolsets, students can experiment with building and maintaining software applications in a safe environment that melds theory and implementation together within the UW CSS 390 Software Engineering Studio course offering. \n\nCollaborative course planning, learning modules, documentation, lecture materials, and operational tools were researched and prepared utilizing prior industry experience with enterprise software engineering management, software development, and site reliability engineering merged with CSSE program learnings and student insights. \n\nThese technical resources helped students to prepare for internships and industry roles by inclusion within curated technical badging experiences centered around TDD, CI/CD, DevOps, Enterprise Agile, and cloud microservices. Students built and enhanced living software solutions in a collaborative environment using modern tools and learning industry based best practices while reinforcing core CSSE material taught in 342, 343, 350, 360, and 370."
        },
        {
            "time": "2:00 PM - 2:15 PM",
            "projectId": "csse-1-200",
            "title": "Relational Algebra Editor",
            "studentName": "Eric Trofimchik",
            "studentMajor": "CSSE",
            "projectType": "UWB CSS Faculty Research",
            "facultyAdvisor": "Mr. Mark Kochanski",
            "posterLink": "./posters/csse/Eric Alex Trofimchik.png",
            "abstract": "I worked on creating a website that allows users to input relational algebra into an editor using the same style of relational algebra symbols as in CSS 475. Relational algebra is a useful tool when working with relational databases, some examples of these are MySQL, Oracle Database, and Microsoft SQL Server. Relational algebra allows a user to create a procedural query which then can be used to create working SQL queries.\n\nThe relational algebra editor allows users to select any of the following types of operators: selection, project, aggregate, cartesian, inner join, left outer join, right outer join, full outer join, semi join left, semi join right, division, union, intersection, and difference. These are the most common types of operators that are used within relational algebra. These operators can be broken down into three types: unary, join, and binary. When a user selects a unary operator the editor would create the unary type node and give the node temporary expression value. \n\nThen it would create a new entity node. When a user selects a join operator the editor would look at the current operator, if there isn’t another operator that was selected beforehand then it would create two new entities and give the node temporary expression value. If there was a current operator then the entity at the current operator would now be on the left side of the new operator. The binary operator would behave in the same way as the join operator in the editor beside not having an expression value.\n\n Both the expression and entity are editable by allowing the user to double clicks on them a text field will render in, where the user can type in the new value and click submit. I used a tree data structure in order to store all of the values that the user put in. With the use of an entity node, unary node, binary node, and a join node to hold the information and code to display a tree to the user.\n\nAs a result, by creating the relational algebra editor, it will allow future students who will work with professor Mark Kochanski to continue where I left off and create a relational algebra to SQL converter. With hopes of adding the ability for the website to be connected to many different database schemas after the addition of the relational algebra to SQL converter."
        },
        {
            "time": "2:15 PM - 2:30 PM",
            "projectId": "csse-1-215",
            "title": "Mighty Muneeb",
            "studentName": "Abdullah Dabbagh",
            "studentMajor": "CSSE",
            "projectType": "Group Project - Student Defined",
            "facultyAdvisor": "Dr. David Socha",
            "posterLink": "./posters/csse/Abdulla Dabbagh - Ahmed Fares.png",
            "abstract": "The idea for this capstone project came from the inspiration my group drew from different courses we attended throughout our academic career. We decided to build a game on the Unity Engine. The reason we chose to create this game was firstly because we agreed that it would be something our group would enjoy and provide a real-life work environment in the field we plan to pursue. Our game is a top-down 4-directional shooting game where the objective is survival. We used many different styles and technologies including UI design, animation, sound management, rendering pipeline, and autonomous behavior.\n\nOur analysis and design skills helped us create our initial goals and requirements. Our software engineering experience helped us create a full calendar with tasks and dates for deliverables. This played a very critical role throughout the whole capstone because it gave us a guide when we felt like we were falling behind. We used a color coordinated Kanban board to organize our weekly tasks and track our progress. This helped us plan weeks when we fell behind or had unforeseen circumstances.\n\nOne of the challenges was being able to collaborate virtually on the Unity engine. When an individual finished their task, they would publish their version of the game to the cloud for the other to sync. This caused some problems because some features did not translate completely on the synced versions. This ultimately caused us to repeat some work. The way we overcame this is by creating a simple version of each feature and testing to see if problems would occur before syncing the high-fidelity version. Our weekly retrospectives and advisor meetings gave us a chance to discuss our issues and exchange ideas and find solutions to our problems.\n\nWe used our playtesting sessions as opportunities to find any bugs or potential enhancements to our game. We were able to collect data and see our product in action which gave us invaluable feedback. Towards the end of the scheduled due date, we were able to successfully complete our minimum implementation and design requirements along with several of our desired ones. We explored different areas of study and were able to learn and implement key features that gave our game a polished finish. This project gave us a small example of a real-life work environment and allowed us to implement many of the skills that we learned.  "
        },
        {
            "time": "2:30 PM - 2:45 PM",
            "projectId": "csse-1-230",
            "title": "Mighty Muneeb",
            "studentName": "Ahmed Fares",
            "studentMajor": "CSSE",
            "projectType": "Group Project - Student Defined",
            "facultyAdvisor": "Dr. David Socha",
            "posterLink": "./posters/csse/Ahmed Isam Fares.png",
            "abstract": "We created a game called Mighty Muneeb, which is a top down 2-dimensional survival-based shooter game that becomes more challenging as each round passes. The goal of the game is to stay alive and complete all 20 rounds to complete level 1. The game offers unique enemies with different behaviors and attributes that will follow you until they are killed. The player is able to shoot his weapon and throw grenades as means to kill the enemies. The game also offers an in-game store that utilizes the gold that is picked up to allow the player to purchase health points and/or ammunition should they find themselves in a difficult position.\n\nThe reason why we decided to develop a game is because I want to become a Product Manager following my graduation. I believe that the best way to prepare for that is by creating a software product from start to finish. The reason why we decided for it to be a game is because of our passion for gaming. This way, we could put ourselves in an environment that would require us to deliver a software product from idea to finish using Agile software development lifecycles. We made the game using a mixture of incremental and iterative life cycles to simulate a professional working environment where we would complete components and iterate on them every week.\n\nThe result was a game with a working UI, and a fully functioning Level 1, with satisfying sounds and aesthetics. Although we have not met all our desired requirements, we met our minimum requirements along with a few desired ones. I learned about how important it is to start with a minimum viable product because of how much time it saves. I also learned about how often things can go wrong, even for unexplained reasons. I also used a lot of my previous learnings from previous courses to incorporate into this project. For example, how to do usability tests and how to create a user-friendly UI from CSS 478. Agile methodologies from CSS 360. Programming techniques from CSS 341 and 342.Overall, I believe my learnings from previous courses as well as my passion for becoming a PM and gaming helped us create a fully functioning game with proper NPC behavior, user interface, level, and audio design. I was able to experience game development, how to lead weekly meetings, defining requirements and collaborating with others, all in a professional setting."
        },
        {
            "time": "2:45 PM - 3:00 PM",
            "projectId": "csse-1-245",
            "title": "Comparing PASTA and STRIDE Threat Modeling on Bank of America's Security",
            "studentName": "Keagan Leon",
            "studentMajor": "CSSE",
            "projectType": "Individual Project - Student Defined",
            "facultyAdvisor": "Dr. Geetha Thamilarasu",
            "posterLink": "./posters/csse/Keagan P Leon.png",
            "abstract": "Bank of America and other financial institutions undergo numerous cyber-attacks each year jeopardizing their data and quality of service. STRIDE and PASTA threat modeling provide ways to identify and mitigate these threats; however, they vary on efficiency. Both methods use different strategies resulting in different responses which can affect the confidentiality, integrity and availability of a company. The goal for this project was to analyze Bank of America’s security using PASTA and STRIDE, prioritize found threats in Bank of America’s application system, and to compare the effectiveness of both procedures. \n\nBank of America has a reputation of being one of the most secure banking institutions, which I thought could yield information about how they may conduct cybersecurity in an effective manner. I chose to perform STRIDE and PASTA since they are common threat modeling tools developers and analysts use to gauge a computer system’s security. Both modeling tools are used to this day, though efficiency varies depending on what situation it is used for. My hopes for using these methods are to recognize the differences between the results and determine which method should be used for this and possibly future security analysis.\n\nAfter analyzing Bank of America’s threats, it was determined attacking banking application servers and networking devices in Bank of America’s banking application would have a critical impact on the company according to the risk matrix tailored to Bank of America; however, would be unlikely to occur. Entering the operating system and/or hard drive and attack on network devices for Bank of America’s ATMs would result with a medium to high impact with a remote to unlikely impact. When comparing methods, it was determined that STRIDE identified, analyzed, and categorized Bank of America’s threats based on class and technical priority, while PASTA identified, analyzed, tests, and prioritized threats based on risk priority. This dynamic allowed PASTA to prioritize threat mitigation according to the company rather than the system’s priority. PASTA proved to be a more effective tool when analyzing Bank of America’s security because it included a more in in depth consideration of perspectives while conducting reconnaissance, finding threats, and prioritizing mitigation."
        }                    
    ]
}